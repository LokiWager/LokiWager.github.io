const z={name:"InvalidComponentArgs",title:"Invalid component arguments.",message:e=>`Invalid arguments passed to${e?` <${e}>`:""} component.`,hint:"Astro components cannot be rendered directly via function call, such as `Component()` or `{items.map(Component)}`."},V={name:"ImageMissingAlt",title:'Image missing required "alt" property.',message:'Image missing "alt" property. "alt" text is required to describe important images on the page.',hint:'Use an empty string ("") for decorative images.'},J={name:"InvalidImageService",title:"Error while loading image service.",message:"There was an error loading the configured image service. Please see the stack trace for more information."},w={name:"MissingImageDimension",title:"Missing image dimensions",message:(e,t)=>`Missing ${e==="both"?"width and height attributes":`${e} attribute`} for ${t}. When using remote images, both dimensions are required unless in order to avoid CLS.`,hint:"If your image is inside your `src` folder, you probably meant to import it instead. See [the Imports guide for more information](https://docs.astro.build/en/guides/imports/#other-assets). You can also use `inferSize={true}` for remote images to get the original dimensions."},B={name:"FailedToFetchRemoteImageDimensions",title:"Failed to retrieve remote image dimensions",message:e=>`Failed to get the dimensions for ${e}.`,hint:"Verify your remote image URL is accurate, and that you are not using `inferSize` with a file located in your `public/` folder."},b={name:"UnsupportedImageFormat",title:"Unsupported image format",message:(e,t,r)=>`Received unsupported format \`${e}\` from \`${t}\`. Currently only ${r.join(", ")} are supported by our image services.`,hint:"Using an `img` tag directly instead of the `Image` component might be what you're looking for."},M={name:"UnsupportedImageConversion",title:"Unsupported image conversion",message:"Converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images is not currently supported."},y={name:"ExpectedImage",title:"Expected src to be an image.",message:(e,t,r)=>`Expected \`src\` property for \`getImage\` or \`<Image />\` to be either an ESM imported image or a string with the path of a remote image. Received \`${e}\` (type: \`${t}\`).

Full serialized options received: \`${r}\`.`,hint:"This error can often happen because of a wrong path. Make sure the path to your image is correct. If you're passing an async function, make sure to call and await it."},Y={name:"ExpectedImageOptions",title:"Expected image options.",message:e=>`Expected getImage() parameter to be an object. Received \`${e}\`.`},U={name:"IncompatibleDescriptorOptions",title:"Cannot set both `densities` and `widths`",message:"Only one of `densities` or `widths` can be specified. In most cases, you'll probably want to use only `widths` if you require specific widths.",hint:"Those attributes are used to construct a `srcset` attribute, which cannot have both `x` and `w` descriptors."},v={name:"LocalImageUsedWrongly",title:"Local images must be imported.",message:e=>`\`Image\`'s and \`getImage\`'s \`src\` parameter must be an imported image or an URL, it cannot be a string filepath. Received \`${e}\`.`,hint:"If you want to use an image from your `src` folder, you need to either import it or if the image is coming from a content collection, use the [image() schema helper](https://docs.astro.build/en/guides/images/#images-in-content-collections). See https://docs.astro.build/en/guides/images/#src-required for more information on the `src` property."},K={name:"AstroGlobUsedOutside",title:"Astro.glob() used outside of an Astro file.",message:e=>`\`Astro.glob(${e})\` can only be used in \`.astro\` files. \`import.meta.glob(${e})\` can be used instead to achieve a similar result.`,hint:"See Vite's documentation on `import.meta.glob` for more information: https://vitejs.dev/guide/features.html#glob-import"},Q={name:"AstroGlobNoMatch",title:"Astro.glob() did not match any files.",message:e=>`\`Astro.glob(${e})\` did not return any matching files.`,hint:"Check the pattern for typos."};function F(e){return e.replace(/\r\n|\r(?!\n)|\n/g,`
`)}function T(e,t){if(!t||t.line===void 0||t.column===void 0)return"";const r=F(e).split(`
`).map(i=>i.replace(/\t/g,"  ")),s=[];for(let i=-2;i<=2;i++)r[t.line+i]&&s.push(t.line+i);let a=0;for(const i of s){let o=`> ${i}`;o.length>a&&(a=o.length)}let n="";for(const i of s){const o=i===t.line-1;n+=o?"> ":"  ",n+=`${i+1} | ${r[i]}
`,o&&(n+=`${Array.from({length:a}).join(" ")}  | ${Array.from({length:t.column}).join(" ")}^
`)}return n}class g extends Error{loc;title;hint;frame;type="AstroError";constructor(t,r){const{name:s,title:a,message:n,stack:i,location:o,hint:l,frame:f}=t;super(n,r),this.title=a,this.name=s,n&&(this.message=n),this.stack=i||this.stack,this.loc=o,this.hint=l,this.frame=f}setLocation(t){this.loc=t}setName(t){this.name=t}setMessage(t){this.message=t}setHint(t){this.hint=t}setFrame(t,r){this.frame=T(t,r)}static is(t){return t.type==="AstroError"}}function L(e){return e.endsWith("/")?e.slice(0,e.length-1):e}function R(e){return e.startsWith("/")?e.substring(1):e}function P(e){return e.replace(/^\/|\/$/g,"")}function O(e){return typeof e=="string"||e instanceof String}function x(...e){return e.filter(O).map((t,r)=>r===0?L(t):r===e.length-1?R(t):P(t)).join("/")}function A(e){return/^(?:http|ftp|https|ws):?\/\//.test(e)||e.startsWith("data:")}const I=["jpeg","jpg","png","tiff","webp","gif","svg","avif"],S="webp",j=["src","width","height","format","quality"];function d(e){return typeof e=="object"}function X(e){return typeof e=="string"}async function Z(e){return typeof e=="object"&&"then"in e?(await e).default??await e:e}function C(e,t){return _(e,t.protocol)&&$(e,t.hostname,!0)&&D(e,t.port)&&H(e,t.pathname)}function D(e,t){return!t||t===e.port}function _(e,t){return!t||t===e.protocol.slice(0,-1)}function $(e,t,r){if(t){if(!r||!t.startsWith("*"))return t===e.hostname;if(t.startsWith("**.")){const s=t.slice(2);return s!==e.hostname&&e.hostname.endsWith(s)}else if(t.startsWith("*.")){const s=t.slice(1);return e.hostname.replace(s,"").split(".").filter(Boolean).length===1}}else return!0;return!1}function H(e,t,r){if(t)if(t.endsWith("*")){if(t.endsWith("/**")){const s=t.slice(0,-2);return s!==e.pathname&&e.pathname.startsWith(s)}else if(t.endsWith("/*")){const s=t.slice(0,-1);return e.pathname.replace(s,"").split("/").filter(Boolean).length===1}}else return t===e.pathname;else return!0;return!1}function q(e,{domains:t=[],remotePatterns:r=[]}){if(!A(e))return!1;const s=new URL(e);return t.some(a=>$(s,a))||r.some(a=>C(s,a))}function ee(e){return e?"transform"in e:!1}const k={propertiesToHash:j,validateOptions(e){if(!e.src||typeof e.src!="string"&&typeof e.src!="object")throw new g({...y,message:y.message(JSON.stringify(e.src),typeof e.src,JSON.stringify(e,(t,r)=>r===void 0?null:r))});if(d(e.src)){if(!I.includes(e.src.format))throw new g({...b,message:b.message(e.src.format,e.src.src,I)});if(e.widths&&e.densities)throw new g(U);if(e.src.format==="svg"&&(e.format="svg"),e.src.format==="svg"&&e.format!=="svg"||e.src.format!=="svg"&&e.format==="svg")throw new g(M)}else{if(e.src.startsWith("/@fs/")||!A(e.src)&&!e.src.startsWith("/"))throw new g({...v,message:v.message(e.src)});let t;if(!e.width&&!e.height?t="both":!e.width&&e.height?t="width":e.width&&!e.height&&(t="height"),t)throw new g({...w,message:w.message(t,e.src)})}return e.format||(e.format=S),e.width&&(e.width=Math.round(e.width)),e.height&&(e.height=Math.round(e.height)),e},getHTMLAttributes(e){const{targetWidth:t,targetHeight:r}=W(e),{src:s,width:a,height:n,format:i,quality:o,densities:l,widths:f,formats:p,...h}=e;return{...h,width:t,height:r,loading:h.loading??"lazy",decoding:h.decoding??"async"}},getSrcSet(e){const t=[],{targetWidth:r}=W(e),{widths:s,densities:a}=e,n=e.format??S;let i=e.width,o=1/0;d(e.src)&&(i=e.src.width,o=i);const{width:l,height:f,...p}=e,h=[];if(a){const m=a.map(c=>typeof c=="number"?c:parseFloat(c)),u=m.sort().map(c=>Math.round(r*c));h.push(...u.map((c,E)=>({maxTargetWidth:Math.min(c,o),descriptor:`${m[E]}x`})))}else s&&h.push(...s.map(m=>({maxTargetWidth:Math.min(m,o),descriptor:`${m}w`})));for(const{maxTargetWidth:m,descriptor:u}of h){const c={...p};m!==i?c.width=m:e.width&&e.height&&(c.width=e.width,c.height=e.height),t.push({transform:c,descriptor:u,attributes:{type:`image/${n}`}})}return t},getURL(e,t){const r=new URLSearchParams;if(d(e.src))r.append("href",e.src.src);else if(q(e.src,t))r.append("href",e.src);else return e.src;return Object.entries({w:"width",h:"height",q:"quality",f:"format"}).forEach(([n,i])=>{e[i]&&r.append(n,e[i].toString())}),`${x("/","/_image")}?${r}`},parseURL(e){const t=e.searchParams;return t.has("href")?{src:t.get("href"),width:t.has("w")?parseInt(t.get("w")):void 0,height:t.has("h")?parseInt(t.get("h")):void 0,format:t.get("f"),quality:t.get("q")}:void 0}};function W(e){let t=e.width,r=e.height;if(d(e.src)){const s=e.src.width/e.src.height;r&&!t?t=Math.round(r*s):t&&!r?r=Math.round(t/s):!t&&!r&&(t=e.src.width,r=e.src.height)}return{targetWidth:t,targetHeight:r}}const N={...k,propertiesToHash:["src"],async transform(e,t){return{data:e,format:t.format}}};var G=N;const te=Object.freeze(Object.defineProperty({__proto__:null,default:G},Symbol.toStringTag,{value:"Module"}));export{g as A,j as D,Y as E,B as F,z as I,K as a,Q as b,y as c,d,ee as e,J as f,V as g,X as i,te as n,Z as r};
