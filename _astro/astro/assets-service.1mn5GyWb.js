const O="modulepreload",M=function(e){return"/"+e},b={},P=function(t,r,i){let o=Promise.resolve();if(r&&r.length>0){const a=document.getElementsByTagName("link");o=Promise.all(r.map(s=>{if(s=M(s),s in b)return;b[s]=!0;const n=s.endsWith(".css"),g=n?'[rel="stylesheet"]':"";if(!!i)for(let l=a.length-1;l>=0;l--){const h=a[l];if(h.href===s&&(!n||h.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${s}"]${g}`))return;const m=document.createElement("link");if(m.rel=n?"stylesheet":O,n||(m.as="script",m.crossOrigin=""),m.href=s,document.head.appendChild(m),n)return new Promise((l,h)=>{m.addEventListener("load",l),m.addEventListener("error",()=>h(new Error(`Unable to preload CSS for ${s}`)))})}))}return o.then(()=>t()).catch(a=>{const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=a,window.dispatchEvent(s),!s.defaultPrevented)throw a})},te={name:"InvalidComponentArgs",title:"Invalid component arguments.",message:e=>`Invalid arguments passed to${e?` <${e}>`:""} component.`,hint:"Astro components cannot be rendered directly via function call, such as `Component()` or `{items.map(Component)}`."},re={name:"ImageMissingAlt",title:'Image missing required "alt" property.',message:'Image missing "alt" property. "alt" text is required to describe important images on the page.',hint:'Use an empty string ("") for decorative images.'},_={name:"InvalidImageService",title:"Error while loading image service.",message:"There was an error loading the configured image service. Please see the stack trace for more information."},v={name:"MissingImageDimension",title:"Missing image dimensions",message:(e,t)=>`Missing ${e==="both"?"width and height attributes":`${e} attribute`} for ${t}. When using remote images, both dimensions are always required in order to avoid CLS.`,hint:"If your image is inside your `src` folder, you probably meant to import it instead. See [the Imports guide for more information](https://docs.astro.build/en/guides/imports/#other-assets)."},y={name:"UnsupportedImageFormat",title:"Unsupported image format",message:(e,t,r)=>`Received unsupported format \`${e}\` from \`${t}\`. Currently only ${r.join(", ")} are supported by our image services.`,hint:"Using an `img` tag directly instead of the `Image` component might be what you're looking for."},H={name:"UnsupportedImageConversion",title:"Unsupported image conversion",message:"Converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images is not currently supported."},I={name:"ExpectedImage",title:"Expected src to be an image.",message:(e,t,r)=>`Expected \`src\` property for \`getImage\` or \`<Image />\` to be either an ESM imported image or a string with the path of a remote image. Received \`${e}\` (type: \`${t}\`).

Full serialized options received: \`${r}\`.`,hint:"This error can often happen because of a wrong path. Make sure the path to your image is correct. If you're passing an async function, make sure to call and await it."},S={name:"ExpectedImageOptions",title:"Expected image options.",message:e=>`Expected getImage() parameter to be an object. Received \`${e}\`.`},j={name:"IncompatibleDescriptorOptions",title:"Cannot set both `densities` and `widths`",message:"Only one of `densities` or `widths` can be specified. In most cases, you'll probably want to use only `widths` if you require specific widths.",hint:"Those attributes are used to construct a `srcset` attribute, which cannot have both `x` and `w` descriptors."},A={name:"LocalImageUsedWrongly",title:"Local images must be imported.",message:e=>`\`Image\`'s and \`getImage\`'s \`src\` parameter must be an imported image or an URL, it cannot be a string filepath. Received \`${e}\`.`,hint:"If you want to use an image from your `src` folder, you need to either import it or if the image is coming from a content collection, use the [image() schema helper](https://docs.astro.build/en/guides/images/#images-in-content-collections) See https://docs.astro.build/en/guides/images/#src-required for more information on the `src` property."},se={name:"AstroGlobUsedOutside",title:"Astro.glob() used outside of an Astro file.",message:e=>`\`Astro.glob(${e})\` can only be used in \`.astro\` files. \`import.meta.glob(${e})\` can be used instead to achieve a similar result.`,hint:"See Vite's documentation on `import.meta.glob` for more information: https://vitejs.dev/guide/features.html#glob-import"},ie={name:"AstroGlobNoMatch",title:"Astro.glob() did not match any files.",message:e=>`\`Astro.glob(${e})\` did not return any matching files. Check the pattern for typos.`};function x(e){return e.replace(/\r\n|\r(?!\n)|\n/g,`
`)}function k(e,t){if(!t||t.line===void 0||t.column===void 0)return"";const r=x(e).split(`
`).map(s=>s.replace(/\t/g,"  ")),i=[];for(let s=-2;s<=2;s++)r[t.line+s]&&i.push(t.line+s);let o=0;for(const s of i){let n=`> ${s}`;n.length>o&&(o=n.length)}let a="";for(const s of i){const n=s===t.line-1;a+=n?"> ":"  ",a+=`${s+1} | ${r[s]}
`,n&&(a+=`${Array.from({length:o}).join(" ")}  | ${Array.from({length:t.column}).join(" ")}^
`)}return a}class f extends Error{loc;title;hint;frame;type="AstroError";constructor(t,...r){super(...r);const{name:i,title:o,message:a,stack:s,location:n,hint:g,frame:c}=t;this.title=o,this.name=i,a&&(this.message=a),this.stack=s||this.stack,this.loc=n,this.hint=g,this.frame=c}setLocation(t){this.loc=t}setName(t){this.name=t}setMessage(t){this.message=t}setHint(t){this.hint=t}setFrame(t,r){this.frame=k(t,r)}static is(t){return t.type==="AstroError"}}function F(e){return e.endsWith("/")?e.slice(0,e.length-1):e}function C(e){return e.startsWith("/")?e.substring(1):e}function q(e){return e.replace(/^\/|\/$/g,"")}function D(e){return typeof e=="string"||e instanceof String}function N(...e){return e.filter(D).map((t,r)=>r===0?F(t):r===e.length-1?C(t):q(t)).join("/")}function $(e){return/^(http|ftp|https|ws):?\/\//.test(e)||e.startsWith("data:")}const T=["jpeg","jpg","png","tiff","webp","gif","svg","avif"],L="webp",U=["src","width","height","format","quality"];function G(e){return e?"transform"in e:!1}const p={propertiesToHash:U,validateOptions(e){if(!e.src||typeof e.src!="string"&&typeof e.src!="object")throw new f({...I,message:I.message(JSON.stringify(e.src),typeof e.src,JSON.stringify(e,(t,r)=>r===void 0?null:r))});if(u(e.src)){if(!T.includes(e.src.format))throw new f({...y,message:y.message(e.src.format,e.src.src,T)});if(e.widths&&e.densities)throw new f(j);if(e.src.format==="svg"&&(e.format="svg"),e.src.format==="svg"&&e.format!=="svg"||e.src.format!=="svg"&&e.format==="svg")throw new f(H)}else{if(e.src.startsWith("/@fs/")||!$(e.src)&&!e.src.startsWith("/"))throw new f({...A,message:A.message(e.src)});let t;if(!e.width&&!e.height?t="both":!e.width&&e.height?t="width":e.width&&!e.height&&(t="height"),t)throw new f({...v,message:v.message(t,e.src)})}return e.format||(e.format=L),e.width&&(e.width=Math.round(e.width)),e.height&&(e.height=Math.round(e.height)),e},getHTMLAttributes(e){const{targetWidth:t,targetHeight:r}=E(e),{src:i,width:o,height:a,format:s,quality:n,densities:g,widths:c,formats:m,...l}=e;return{...l,width:t,height:r,loading:l.loading??"lazy",decoding:l.decoding??"async"}},getSrcSet(e){const t=[],{targetWidth:r}=E(e),{widths:i,densities:o}=e,a=e.format??L;let s=e.width,n=1/0;u(e.src)&&(s=e.src.width,n=s);const{width:g,height:c,...m}=e,l=[];if(o){const h=o.map(d=>typeof d=="number"?d:parseFloat(d)),w=h.sort().map(d=>Math.round(r*d));l.push(...w.map((d,R)=>({maxTargetWidth:Math.min(d,n),descriptor:`${h[R]}x`})))}else i&&l.push(...i.map(h=>({maxTargetWidth:Math.min(h,n),descriptor:`${h}w`})));for(const{maxTargetWidth:h,descriptor:w}of l){const d={...m};h!==s?d.width=h:e.width&&e.height&&(d.width=e.width,d.height=e.height),t.push({transform:d,descriptor:w,attributes:{type:`image/${a}`}})}return t},getURL(e,t){const r=new URLSearchParams;if(u(e.src))r.append("href",e.src.src);else if(Q(e.src,t))r.append("href",e.src);else return e.src;return Object.entries({w:"width",h:"height",q:"quality",f:"format"}).forEach(([a,s])=>{e[s]&&r.append(a,e[s].toString())}),`${N("/","/_image")}?${r}`},parseURL(e){const t=e.searchParams;return t.has("href")?{src:t.get("href"),width:t.has("w")?parseInt(t.get("w")):void 0,height:t.has("h")?parseInt(t.get("h")):void 0,format:t.get("f"),quality:t.get("q")}:void 0}};function E(e){let t=e.width,r=e.height;if(u(e.src)){const i=e.src.width/e.src.height;r&&!t?t=Math.round(r*i):t&&!r?r=Math.round(t/i):!t&&!r&&(t=e.src.width,r=e.src.height)}return{targetWidth:t,targetHeight:r}}function B(e,t){return z(e,t.protocol)&&W(e,t.hostname,!0)&&V(e,t.port)&&J(e,t.pathname,!0)}function V(e,t){return!t||t===e.port}function z(e,t){return!t||t===e.protocol.slice(0,-1)}function W(e,t,r){if(t){if(!r||!t.startsWith("*"))return t===e.hostname;if(t.startsWith("**.")){const i=t.slice(2);return i!==e.hostname&&e.hostname.endsWith(i)}else if(t.startsWith("*.")){const i=t.slice(1);return e.hostname.replace(i,"").split(".").filter(Boolean).length===1}}else return!0;return!1}function J(e,t,r){if(t){if(!r||!t.endsWith("*"))return t===e.pathname;if(t.endsWith("/**")){const i=t.slice(0,-2);return i!==e.pathname&&e.pathname.startsWith(i)}else if(t.endsWith("/*")){const i=t.slice(0,-1);return e.pathname.replace(i,"").split("/").filter(Boolean).length===1}}else return!0;return!1}function u(e){return typeof e=="object"}function K(e){return typeof e=="string"}function Q(e,{domains:t=[],remotePatterns:r=[]}){if(!$(e))return!1;const i=new URL(e);return t.some(o=>W(i,o))||r.some(o=>B(i,o))}async function X(){if(!globalThis?.astroAsset?.imageService){const{default:e}=await P(()=>Promise.resolve().then(()=>ee),void 0).catch(t=>{const r=new f(_);throw r.cause=t,r});return globalThis.astroAsset||(globalThis.astroAsset={}),globalThis.astroAsset.imageService=e,e}return globalThis.astroAsset.imageService}async function ae(e,t){if(!e||typeof e!="object")throw new f({...S,message:S.message(JSON.stringify(e))});const r=await X(),i={...e,src:typeof e.src=="object"&&"then"in e.src?(await e.src).default??await e.src:e.src},o=u(i.src)?i.src.clone??i.src:i.src;i.src=o;const a=r.validateOptions?await r.validateOptions(i,t):i,s=r.getSrcSet?await r.getSrcSet(a,t):[];let n=await r.getURL(a,t),g=await Promise.all(s.map(async c=>({transform:c.transform,url:await r.getURL(c.transform,t),descriptor:c.descriptor,attributes:c.attributes})));if(G(r)&&globalThis.astroAsset.addStaticImage&&!(K(a.src)&&n===a.src)){const c=r.propertiesToHash??U;n=globalThis.astroAsset.addStaticImage(a,c),g=s.map(m=>({transform:m.transform,url:globalThis.astroAsset.addStaticImage(m.transform,c),descriptor:m.descriptor,attributes:m.attributes}))}return{rawOptions:i,options:a,src:n,srcSet:{values:g,attribute:g.map(c=>`${c.url} ${c.descriptor}`).join(", ")},attributes:r.getHTMLAttributes!==void 0?await r.getHTMLAttributes(a,t):{}}}const Y={propertiesToHash:["src"],validateOptions:p.validateOptions,getURL:p.getURL,parseURL:p.parseURL,getHTMLAttributes:p.getHTMLAttributes,async transform(e,t){return{data:e,format:t.format}}};var Z=Y;const ee=Object.freeze(Object.defineProperty({__proto__:null,default:Z},Symbol.toStringTag,{value:"Module"}));export{f as A,re as I,P as _,se as a,ie as b,te as c,ae as g,u as i};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}